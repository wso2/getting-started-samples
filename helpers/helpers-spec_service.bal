// AUTO-GENERATED FILE.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;
import ballerina/log;
import ballerina/mime;
import ballerina/uuid;
import ballerinax/openai.chat;
import ballerina/data.csv;
import ballerina/io;

configurable string openAIKey = ?;

configurable string host = "localhost";
configurable int port = 8081;

configurable string aiModel = "gpt-4o-mini";

// Constants
const int MAX_BASE64_STRING_SIZE = 100;
const string[] targetHeaders = ["X-Forwarded-For", "X-Client-IP", "Via", "X-Real-IP"];
const string basePrompt = "Fix grammar and spelling mistakes of this content: ";
final string:RegExp decode_pattern = re `^[0-9a-zA-Z=]+$`;
final string:RegExp encode_pattern = re `^[0-9a-zA-Z\s!$-_çñÇÑ]+$`;

const map<decimal> RATES_TO_USD = {
    "USD": 1.0,
    "EUR": 1.09,
    "GBP": 1.25,
    "JPY": 0.0066,
    "AUD": 0.67,
    "CAD": 0.74,
    "INR": 0.012,
    "LKR": 0.0033
};

//AI Variables
final readonly & http:RetryConfig retryConfig = {
            interval: 5, // Initial retry interval in seconds.
            count: 3, // Number of retry attempts before stopping.
            backOffFactor: 2.0 // Multiplier of the retry interval.
        };

final chat:Client openAIChat = check new ({auth: {token: openAIKey}, retryConfig});

listener http:Listener main_endpoint = new (port, config = {host});


function searchClientIpHeaders(http:Headers headers) returns map<string>|error =>  
    map from string header in targetHeaders 
        where headers.hasHeader(header)  
        select [header, check headers.getHeader(header)];  


service / on main_endpoint {
    # Returns the client IP address.
    # + return - returns IP message or unknown if the remote IP can't be found in the remoteAddress block.
    #
    # http:Ok (Get the client IP address.)
    # If the hc-respond call fails, a 500 error will be generated automatically.
    resource function get ip(@http:CallerInfo {respondType: ip_response} http:Caller hc) returns error? {

        ip_response response;
        do {
            response = {origin: hc.remoteAddress.ip};
        } on fail {
            response = {origin: "unknown"};
        }
        error? res = hc->respond(response);
        if res is error {
            log:printError("Error responding to the client", res);
        }
    }

    # Returns all HTTP headers from the request
    # + return - returns a map of headers or error
    resource function get headers(http:Headers headers) returns specific_headers_response|Error_serverFailure {
        do {
            map<string> filteredHeaders = check searchClientIpHeaders(headers);
            // Ballerina will automatically infer the type and map the record structure.
            return {headers: filteredHeaders};
        } on fail error e {
            log:printError("Error retrieving headers", e, e.stackTrace());
            return <Error_serverFailure> {  
                body: {  
                    message: "Failed to retrieve headers",  
                    code: "err_007"  
                }  
            };  
        }
    }

    # Returns the value of the user-agent header
    # The http:header annotation ensures that a default error message will be automatically
    # created and returned if the header can't be found.
    # + return - returns can be any of following types 
    # http:Ok (Get a UUID V4.)
    resource function get user\-agent(@http:Header string user\-agent) returns ua_response {
        ua_response response = {user\-agent};
        return response;
    }

    # Returns a unique ID as per UUID v4 spec
    #
    # + return - returns can be any of following types 
    # http:Ok (Get a UUID V4.)
    # http:Error_serverFailure (Response for any error)
    resource function get uuid() returns uuid_response|Error_serverFailure {

        do {
            string tempUuid = uuid:createRandomUuid();
            //Next 2 lines are equivalent to:
            //uuid_response response = {uuid: tempUuid};
            //return response;
            return  {uuid: tempUuid};
        } on fail error e {
            log:printError("UUID Generated failed: " + e.toString());
            Error_serverFailure response = {body: {message: "failed to create UUID", code: "err_001"}};
            return response;
        }
    }

    resource function post 'base64/decode/[string value]() returns Base64_responseOk|Error_responseBadRequest {
        // Validate incoming string
        log:printDebug("Incoming text", value = value);

        if value.length() > MAX_BASE64_STRING_SIZE {
            return {body: {message: "String is too long. Sorry.", code: "err_002"}};
        }

        if !value.matches(decode_pattern) {  
            return {body: {message: "Invalid characters. Sorry.", code: "err_003"}};
        }
        string|error decodedValue = mime:base64Decode(value).ensureType();

        if (decodedValue is string) {
            log:printDebug("Decoded text", value =  decodedValue);
            return {body: {value: decodedValue}};
        } else {
            log:printError("Decoding error: " + decodedValue.toString());
            return  {body: {message: "unable to decode", code: "err_004"}};
        }
    }

    resource function post 'base64/encode/[string value]() returns Base64_responseOk|Error_responseBadRequest {
        log:printDebug("Encoding text", value = value);

        // Validate incoming string 
        if (value.length() > MAX_BASE64_STRING_SIZE) {
            return {body: {message: "String is too large. Sorry.", code: "err_002"}};
        }

        if !encode_pattern.isFullMatch(value) {
            return  {body: {message: "Invalid characters. Sorry.", code: "err_003"}};
        }

        string|error encodedValue = mime:base64Encode(value).ensureType();

        if (encodedValue is string) {
            Base64_responseOk response = {body: {"value": encodedValue}};
            log:printDebug("Encoded text", encodedValue = encodedValue);
            return response;
        } else {
            Error_responseBadRequest response = {body: {message: "unable to encode", code: "err_006"}};
            log:printDebug("Encoding error: " + encodedValue.toString());
            return response;
        }
    }

    resource function post ai/spelling(@http:Payload ai_spelling_payload data) returns ai_spelling_responseOk|Error_responseBadRequest|error {

        // Extract body contents

        chat:CreateChatCompletionRequest request = {
            model: aiModel,
            messages: [
                {
                    "role": "user",
                    "content": basePrompt.concat(data.text)
                }
            ]
        };
        chat:CreateChatCompletionResponse ai_response = check openAIChat->/chat/completions.post(request);
        string? correctedText = ai_response.choices[0].message.content;

        if (correctedText is ()) {
            return  {body: {message: "Could not correct grammar/spelling", code: "err_008"}};
        } else {
            return  {body: {correctedText}};
        }

    }

    resource function post currency/rate(curreny_converter_payload payload) returns curreny_converter_responseOk|Error_responseBadRequest|error {

        curreny_converter_payload {fromCurrency, toCurrency} = payload;

        decimal? fromRate = RATES_TO_USD[fromCurrency.trim().toUpperAscii()];
        decimal? toRate = RATES_TO_USD[toCurrency.trim().toUpperAscii()];

        if fromRate == () || toRate == () {
            return {
                body: {
                    message: "One or both currencies are not supported. Supported currencies are: " + RATES_TO_USD.keys().toString(),
                    code: "err_009"
                }
            };
        }
        decimal effectiveRate = fromRate / toRate;
        return {
            body: {
                fromCurrency: fromCurrency,
                toCurrency: toCurrency,
                rate: effectiveRate
            }
        };
    }

    resource function get countries() returns Country[]|http:InternalServerError {

        string|error csvContent = io:fileReadString("resources/countries.csv");
        if csvContent is error {
            log:printError("Failed to read countries CSV file", message = csvContent.message());
            return <http:InternalServerError>{body: "Unable to load country data"};
        }

        Country[]|error countries = csv:parseString(csvContent);
        if countries is error {
            log:printError("Failed to parse countries CSV content", message = countries.message());
            return <http:InternalServerError>{body: "Unable to load country data"};
        }
        return countries;
    }
}
